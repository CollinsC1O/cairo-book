
[[questions]]
type = "Tracing"
prompt.prompt = """
struct Student<T> {
    name: T,
    age: T,
    level: T
}

fn main(){
    let mut studentI = Student {name: 'Celine', age: 19, level: 9, };

    let mut age = studentI.age;
    let mut level = studentI.level;
    
    println!("{}", level);
}
"""
answer.doesCompile = true
answer.stdout = "9"
context = """
This compiles for several reasons, including accurate trait implementations, 
proper function calls and returns, correct memory management, Adherence to Cairo VM's 
Constraints, proper variable scope handling, and proper type declarations and usage.
"""

[[questions]]
type = "Tracing"
prompt.prompt = """
#[derive(Drop)]
struct wallet<T>{
    balance: T,
    address: W
}

fn main() {
    let mut account = wallet{ balance: 10, address: 200 };

    let balance = account.balance;
    print!("wallet balance is {}", balance);
    let address = account.address;
    print!("wallet address is {}", address);
}
"""
answer.doesCompile = false
context = """
The code fails to compile because the struct fields have different types. To address this, 
another generic type should be introduced after 'T' in the struct definition to maintain 
consistency. Let's utilize 'W', as it was previously employed as a type for the 'address' 
field. Consequently, the struct should be implemented as follows:
```
struct Wallet<T, W> { 
    balance: T, 
    address: W 
}
```
"""

[[questions]]
type = "MultipleChoice"
prompt.prompt = "What is a trait bound on a generic type"
prompt.distractors = """
    "This is to bound traits together",
    "A trait bound make it possible for a generic function to compile",
    "A trait bound ensures that a generic type implements various behaviors"
answer.answer = "A trait bound demand that a generic type adopts specific behavior 
defined by a trait"
context = """
The function smallest_element is bound to types T that must implement PartialOrd, 
Copy, and Drop traits. T must support comparisons (PartialOrd), copying (Copy), 
and must be droppable (Drop). The function takes a snapshot of an array 
of type T and returns the smallest element found in the array. This function is trait bound.
```
fn smallest_element<T, +PartialOrd<T>, +Copy<T>, +Drop<T>>(list: @Array<T>) -> T {
    let mut smallest = *list[0];
    let mut index = 1;
    loop {
        if index >= list.len() {
            break smallest;
        }
        if *list[index] < smallest {
            smallest = *list[index];
        }
        index = index + 1;
    }
}
```
"""